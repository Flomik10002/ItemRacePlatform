# Предложение по полной переписи Item Race (UI остается, тех. оболочка переписывается)

Дата: 2026-02-12  
Объем: Полная перепись слоя взаимодействия client-server с сохранением текущих UI-экранов.

## Кратко

Короткий ответ: да, перепись на основе Spring может быть лучше, но только если делать это по контракту и поэтапно.

Если просто «переписать на Spring» без протокольных контрактов и плана миграции, мы воспроизведем тот же класс багов в другом стеке.

## Что здесь значит «лучше»

Для этого проекта «лучше» должно означать:

1. Детерминированное поведение протокола (без скрытых alias-команд и «призрачных» состояний).
2. Типизированные контракты, генерируемые и для сервера, и для клиента.
3. Явная state machine жизненного цикла комнаты/сессии.
4. Нормальная наблюдаемость (логи, метрики, tracing ID).
5. Повторяемые локальные и интеграционные тесты циклов start-stop-restart.

## Стоит ли использовать Spring?

## Плюсы

1. Сильная типизация и валидация из коробки (DTO + Bean Validation).
2. Зрелая поддержка WebSocket в Spring Boot/WebFlux.
3. Более зрелый стек наблюдаемости (Actuator, Micrometer, структурированные логи).
4. Проще масштабировать в долгую (auth, matchmaking, admin API, кластеризация).
5. Одна языковая экосистема с клиентом (Java), проще shared-модели/codegen.

## Минусы

1. Более тяжелый runtime по сравнению с минималистичным Node WS-сервером.
2. Более высокий порог по настройке и архитектуре.
3. Требует дисциплины, чтобы не получить «монолит с аннотациями везде».
4. Стоимость миграции реальна; нужен временный dual-stack.

## Рекомендация

Использовать Spring только в рамках contract-first переписи, а не framework-first переписи.

## Целевая архитектура

## Сервер (Spring Boot)

1. `race-gateway`
- WebSocket endpoint.
- Фрейминг сообщений, привязка auth/session, heartbeat.
- Работа с request ID / correlation ID.

2. `race-domain`
- Чистая state machine комнаты и правила.
- Без сетевого кода и без сериализации.
- Команды: create/join/leave/start/stop/finish/worldState/advancement.

3. `race-application`
- Оркестрирует обработку команд и эмитит domain events.
- Применяет idempotency и concurrency-проверки.

4. `race-observability`
- Структурированные логи с room/player/session ID.
- Метрики: число соединений, число комнат, latency старта, error rate.

5. Storage
- Начать с in-memory состояния.
- По необходимости: Redis для горизонтального масштабирования.

## Клиентская тех. оболочка (UI без изменений)

Сохраняем все текущие UI-экраны и рендер, переписываем только слой взаимодействия:

1. `RaceTransport`
- Единственная зона ответственности: lifecycle WS, reconnect, backoff, heartbeat.

2. `RaceProtocol`
- Сгенерированные DTO-модели + сериализаторы из схемы.
- Без ручных JSON-ключей в UI-потоке.

3. `RaceStore`
- Единый source of truth по состоянию (`IDLE/LOBBY/STARTING/RUNNING/FINISHED` + метаданные).
- Применение событий в reducer-стиле.

4. `RaceController`
- Мост между UI-экшенами, игровыми событиями и командами протокола.
- Без бизнес-логики внутри `RaceLobbyScreen`.

5. `RaceGameBridge`
- Хуки создания мира/финиша и детект состояния «в мире/не в мире».

## Стратегия протокола и code generation

Это ядро переписи.

1. Сначала фиксируем протокол:
- `AsyncAPI` (для WebSocket-сообщений).
- `JSON Schema` для payload и правил валидации.

2. Генерация:
- Серверные DTO + валидаторы.
- Клиентские DTO + parser/encoder.

3. Строгий envelope:

```json
{
  "protocolVersion": "1.0",
  "messageId": "uuid",
  "type": "start_request",
  "timestamp": 1770000000000,
  "payload": {}
}
```

4. Канонический набор сообщений:
- Оставить ровно одну stop-команду (`stop_request`).
- Убрать legacy alias-ы и legacy `ready`.

## Предложение по state machine

Состояния комнаты:

1. `LOBBY`
2. `STARTING`
3. `RUNNING`
4. `FINISHED` (опциональная явная фаза завершения комнаты)

Ключевой инвариант:

- Старт разрешен только если все участники комнаты вне игрового мира.
- Stop возвращает в lobby и из `STARTING`, и из `RUNNING`.
- Любой state transition эмитит явный event и ack.

## План миграции (безопасный cutover)

## Фаза 0: Freeze и baseline

1. Заморозить изменения текущего протокола.
2. Держать регрессионный набор тестов на текущем сервере.
3. Снять golden traces для create/start/stop/restart/reconnect потоков.

## Фаза 1: Contract-first в текущем стеке

1. Описать AsyncAPI/JSON Schema по фактическому поведению.
2. Добавить schema-validation тесты в CI.
3. Нормализовать message names и error codes сначала «на бумаге».

## Фаза 2: Поднять Spring-сервер параллельно

1. Реализовать ту же протокольную семантику.
2. Гонять protocol conformance тесты и против Node, и против Spring.
3. Добавить нагрузочные и chaos-тесты (disconnect/reconnect штормы пакетов).

## Фаза 3: Перепись клиентского адаптера (UI intact)

1. Заменить ручной JSON в `RaceSessionManager` на сгенерированный protocol layer.
2. Ввести `RaceStore` и вынести логику из UI-классов.
3. Добавить feature flag для переключения endpoint stack.

## Фаза 4: Cutover

1. Канареечный rollout (малый процент пользователей).
2. Сверка метрик и логов.
3. Удаление legacy code paths и alias-команд.

## Риски и снижения риска

1. Риск: перепись «уплывет» от текущего игрового поведения.
- Снижение: protocol conformance тесты + golden traces.

2. Риск: миграция слишком надолго заморозит разработку фич.
- Снижение: поэтапный rollout и жестко ограниченный scope (только interaction layer).

3. Риск: сгенерированный код все равно будет обернут ad-hoc логикой.
- Снижение: lint/checkstyle правило, запрещающее raw JSON keys в race-модуле.

4. Риск: edge-case реконнекта вернутся.
- Снижение: детерминированная session binding + idempotent command handling.

## Конкретные цели чистки в текущем коде

1. Полностью убрать client-side отправку legacy `ready`.
2. Заменить 5 stop alias-ов одной канонической командой.
3. Разрезать раздутый `RaceSessionManager` на transport/protocol/store/controller.
4. Добавить stale-socket guard и для входящего text path.
5. Ввести ограниченную очередь pending-сообщений и backpressure-поведение.
6. Вынести hardcoded константы в конфиг (`countdown`, интервалы, default URI).

## Реалистичная оценка сроков

1. Контракт + baseline тестов: 3-5 дней.
2. Spring server MVP parity: 7-12 дней.
3. Перепись клиентской оболочки с сохранением UI: 7-12 дней.
4. Канарейка + стабилизация: 3-7 дней.

Итого: примерно 3-5 недель на надежную миграцию без хаоса в проде.

## Что я могу сделать следующим шагом

1. Черновик `AsyncAPI` по текущему протоколу (из фактического поведения).
2. Канонический protocol v1 (убрать `ready`, унифицировать stop, ввести явные error codes).
3. Скелет новой клиентской оболочки (`RaceTransport`, `RaceProtocol`, `RaceStore`) при сохранении текущего UI.
4. Скелет Spring Boot WS-сервера с command handlers и parity-тестами.

## Финальная рекомендация

Да, полная чистка оправдана.  
Но выигрышная стратегия не «Spring first», а «contract first + generated models + phased migration».

Если подтверждаешь, следующий шаг:

1. зафиксировать protocol v1 schema,
2. убрать legacy-семантику (`ready`, stop alias-ы),
3. затем мигрировать реализацию client/server за стабильным контрактом.
