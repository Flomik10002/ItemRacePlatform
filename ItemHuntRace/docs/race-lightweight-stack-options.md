# Легкие альтернативы Spring для Item Race (с автогенерацией)

Дата: 2026-02-12

## 1. Что такое «автогенерация» простыми словами

Автогенерация здесь означает:

1. Ты один раз описываешь формат сообщений (контракт).
2. Инструмент сам генерирует модели и часть кода для клиента и сервера.
3. Меньше ручного JSON, меньше опечаток, меньше рассинхрона.

Для WebSocket лучше всего использовать:

1. `AsyncAPI` (описание WS-сообщений).
2. `JSON Schema` (валидация payload).

## 2. Важно: фреймворк и автогенерация это разные вещи

Автогенерация не зависит напрямую от Spring/Micronaut/Ktor.  
Можно взять легкий фреймворк и все равно иметь строгий контракт и codegen.

## 3. Варианты без Spring

## Вариант A: Micronaut (Java) + AsyncAPI/JSON Schema

Когда подходит:

1. Хочешь остаться в Java.
2. Нужен легкий runtime и быстрый старт.
3. Нужна типизация и нормальная структура.

Плюсы:

1. Легче Spring по памяти/старту.
2. Хорошо сочетается с Java-клиентом (Minecraft mod).
3. Удобно поддерживать большой проект.

Минусы:

1. Чуть сложнее, чем «минималистичные» фреймворки.
2. Экосистема меньше, чем у Spring.

Сложность: `3/5`

---

## Вариант B: Quarkus (Java) + AsyncAPI/JSON Schema

Когда подходит:

1. Нужна высокая производительность.
2. Нужен легкий Java-сервер в проде.

Плюсы:

1. Быстрый и экономный runtime.
2. Хорош для реактивного WS.
3. Хороший путь к масштабированию.

Минусы:

1. Чуть больше «инженерной» сложности.
2. Для новичка может быть тяжелее Micronaut.

Сложность: `3.5/5`

---

## Вариант C: Ktor (Kotlin) + AsyncAPI/JSON Schema

Когда подходит:

1. Хочешь максимально легкий и понятный сервер.
2. Не против Kotlin.

Плюсы:

1. Очень легкий.
2. Простой для кастомного WS-протокола.
3. Мало «магии», легче дебажить.

Минусы:

1. Нужно писать на Kotlin.
2. Меньше готовых enterprise-шаблонов.

Сложность: `2.5/5`

---

## Вариант D: Javalin (Java) + JSON Schema

Когда подходит:

1. Нужен максимально простой Java-сервер.
2. Хочешь быстро поднять MVP.

Плюсы:

1. Очень маленький и понятный.
2. Минимальный порог входа.

Минусы:

1. Меньше встроенных механизмов (придется строить архитектуру руками).
2. На росте проекта растет шанс «хаоса».

Сложность: `2/5`

---

## Вариант E: Оставить Node.js, но переписать архитектуру (Fastify/ws + AsyncAPI)

Когда подходит:

1. Нужна максимальная скорость разработки.
2. Ок с JavaScript/TypeScript.

Плюсы:

1. Самый быстрый путь к результату.
2. Легкий runtime.

Минусы:

1. Строгая типизация слабее, чем в Java/Kotlin (если не делать TS очень дисциплинированно).
2. Текущие проблемы легко повторить без жестких контрактов.

Сложность: `2/5`

## 4. Матрица сравнения (для твоего кейса)

Оценка: 1..5 (5 = лучше)

| Вариант | Легкость runtime | Простота для старта | Строгая типизация | Удобство для Java-клиента | Рост проекта |
|---|---:|---:|---:|---:|---:|
| Micronaut | 4 | 3 | 5 | 5 | 5 |
| Quarkus | 5 | 2 | 5 | 5 | 5 |
| Ktor | 4 | 4 | 4 | 4 | 4 |
| Javalin | 4 | 5 | 3 | 4 | 3 |
| Node + Fastify/ws | 5 | 5 | 3 | 2 | 3 |

## 5. Что рекомендую именно тебе

С учетом текущего проекта (Minecraft Java client, проблемы контракта, желание «почистить все»):

1. **Лучший баланс**: `Micronaut + AsyncAPI/JSON Schema`.
2. **Если хочешь еще проще и быстрее старт**: `Ktor + AsyncAPI/JSON Schema`.
3. **Если не хочешь менять язык и минимальный риск по миграции**: оставить Node, но строго перейти на contract-first и генерацию.

## 6. Минимальный «безболезненный» план

Неважно какой фреймворк выберешь, делай в таком порядке:

1. Зафиксировать контракт (`AsyncAPI v1`) по текущим сообщениям.
2. Убрать legacy (`ready`, 5 alias-команд stop).
3. Генерировать DTO из схем, не писать JSON-ключи руками.
4. Разделить клиент на `Transport / Protocol / Store / Controller`.
5. Только потом делать миграцию сервера на новый стек.

## 7. Что даст самый большой эффект

Самый большой эффект даст не смена фреймворка, а:

1. строгий контракт сообщений,
2. codegen,
3. тесты на state transitions (`start -> stop -> start`, reconnect, finish).

Фреймворк выбираем уже после этого.

## 8. Итог в одной строке

Если хочешь «легко + надежно + автогенерация» и без Spring:  
**бери Micronaut или Ktor, но обязательно через AsyncAPI/JSON Schema и поэтапную миграцию.**
