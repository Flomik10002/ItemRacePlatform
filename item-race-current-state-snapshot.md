# Item Race — Полный Слепок Текущего Состояния

Дата слепка: 11 февраля 2026  
Статус: рабочий документ для выравнивания контекста перед полным переписыванием клиент-серверного взаимодействия

## 1. Зачем этот документ

Этот документ не про устройство отдельных классов и не про точечные фиксы.  
Это полная контекстная картина на текущий момент:

- где сейчас находится продукт;
- в каком состоянии находится техническая реализация;
- что ты хочешь изменить на самом деле;
- почему текущий подход больше невыгоден;
- какие ограничения важны и что нельзя потерять;
- какие решения нужно принять до начала переписывания.

Документ нужен как единая точка правды для обсуждения и последующей реализации.

## 2. Твоя текущая ситуация (как она выглядит сейчас)

### 2.1 Продуктовая позиция

`Item Race` уже не просто идея. Это режим с реальным продуктовым циклом:

1. Вход в режим.
2. Подключение к серверу.
3. Создание/вход в комнату.
4. Совместный старт.
5. Короткий соревновательный раунд.
6. Итоги.
7. Рематч в том же потоке сессии.

То есть задача уже не "сделать фичу", а стабилизировать продуктовый цикл.

### 2.2 Твоя инженерная позиция

Ты явно видишь, что система превратилась в сложную смесь решений, принятых в разное время:

- часть протокола историческая;
- часть сообщений дублирует друг друга;
- часть поведения формально "работает", но архитектурно хрупкая;
- локальные правки дают эффект "починил одно — вылезло другое".

### 2.3 Важный человеческий контекст

Ты прямо обозначил:

- нет полной ментальной модели текущей реализации;
- нет enterprise-опыта проектирования таких long-lived realtime систем;
- ты не хочешь тратить недели на раскопки старой каши;
- ты хочешь сначала качественно обсудить и собрать цельную картину.

Это абсолютно рациональная позиция для текущего состояния: сначала выравнивание контекста, потом архитектурные решения.

## 3. Что ты уже чётко решил

Это ключевые зафиксированные решения на текущий момент:

1. Нужен **полный rewrite клиент-серверного взаимодействия**.
2. Нужен **greenfield-подход**, а не постепенное "разгребание" существующей мешанины.
3. **UI клиента не трогаем** (визуальный и пользовательский слой должен остаться прежним по поведению).
4. Сейчас фаза **обсуждения и проектирования**, а не "быстро что-то подправить в коде".

## 4. Продуктовая рамка (что нельзя потерять при rewrite)

Из продуктового описания режима вытекают неизменяемые опорные требования:

1. Ясность состояния для игрока в каждый момент.
2. Предсказуемые переходы между фазами.
3. Честные единые условия раунда.
4. Быстрый ритм раундов/рематчей.
5. Надёжность длинной серии матчей в одной комнате.
6. Отсутствие "ложных состояний" (UI не должен показывать одно, когда сервер уже в другом).

Переписывание взаимодействия должно сохранять именно это, а не только "чтобы WebSocket отвечал".

## 5. Слепок текущей системы (высокоуровнево)

### 5.1 Что есть физически в проекте

Сейчас в репозитории сосуществуют:

1. Minecraft-мод (`ItemHuntRace`) с рабочим UI и логикой режима на клиенте.
2. Старый отдельный WS-сервер на Node.js (`ItemHuntRace/server.js`), который сейчас фактически держит прод-жизнь режима.
3. Новый модуль `race-server` на Ktor, но пока в шаблонном состоянии (инфраструктура есть, доменной логики почти нет).

### 5.2 Реальная операционная архитектура "как есть"

Фактическая рабочая связка сейчас:

- Клиент мода -> WS протокол -> Node-сервер -> обратно события клиенту.
- Клиент при этом содержит много логики ожиданий и fallback-поведения для несовершенного протокола.
- Сервер и клиент завязаны на эволюционно сложившийся контракт сообщений.

### 5.3 Что означает "система хрупкая"

Хрупкость в таких системах обычно проявляется не в одном баге, а в наборе эффектов:

1. Состояния размазаны между клиентом и сервером.
2. Есть исторические костыли для совместимости.
3. Много неявных правил, которые "просто нужно помнить".
4. Поведение в edge-cases не определяется формально.
5. Реконнекты, отмены старта и завершения раунда ведут себя неинтуитивно.

Именно это ты сейчас и описываешь как "каша".

## 6. Текущая проблема не техническая, а системная

Важно: проблема не в том, что "Java плохая" или "Node плохой".  
Проблема в том, что модель взаимодействия:

- выросла органически;
- не держится на формальной state-machine модели;
- несёт историческую нагрузку протокола;
- тяжело проверяется и тяжело объясняется.

Поэтому локальные правки дают низкую отдачу, а стоимость понимания контекста резко растёт.

## 7. Почему решение "переписать с нуля" здесь рационально

Решение переписать взаимодействие оправдано, когда выполняются условия:

1. Стоимость стабилизации legacy выше стоимости greenfield.
2. Есть риск бесконечного цикла регрессий.
3. Нужно зафиксировать продуктовые гарантии, а не "чинить по факту".
4. Нужна прозрачная модель для дальнейшего развития.

Твоя ситуация под это подпадает.

## 8. Что именно значит "не трогать UI"

Это не просто "не менять кнопки". Это означает:

1. Не ломать пользовательский сценарий.
2. Не менять привычные экраны и ожидаемую реакцию интерфейса.
3. Сохранить ощущения потока игры.
4. Подменить внутренний транспорт/протокол так, чтобы UI продолжал жить на тех же продуктовых смыслах.

То есть rewrite должен произойти в слое взаимодействия и state orchestration, а не в презентационном слое.

## 9. Твой текущий запрос к процессу работы

Ты просишь не "сразу писать код", а:

1. Погрузить тебя в систему целиком.
2. Помочь собрать целостную модель.
3. Снять хаос в голове до этапа реализации.
4. Идти поэтапно и прозрачно.

Это правильный формат для такого типа rewrite.

## 10. Ограничения и инварианты на текущем этапе

### 10.1 Жёсткие ограничения

1. UI не трогаем.
2. Фаза обсуждения важнее немедленных code-фиков.
3. Избегаем косметического рефакторинга legacy ради рефакторинга.

### 10.2 Инварианты продукта

1. Комната как основной юнит сессии.
2. Лидерство как управленческая роль.
3. Общая цель раунда для всех.
4. Честный старт и понятный результат.
5. Рематч-цикл без деградации состояния.

## 11. Базовые риски, если действовать без общей картины

1. Повторная сборка той же архитектурной проблемы на новом стеке.
2. Скрытая несовместимость с текущим UX при "формально рабочем" протоколе.
3. Перенос старых неявных правил в новый код один-в-один.
4. Затяжной rewrite без критериев готовности.
5. Потеря доверия к стабильности режима после релиза rewrite.

## 12. Базовые риски, если оставаться на legacy-подходе

1. Постоянные регрессии в переходах фаз.
2. Рост стоимости каждой новой правки.
3. Усталость от непредсказуемости.
4. Замедление продукта из-за технической вязкости.
5. В какой-то момент полный rewrite всё равно станет неизбежен, но дороже.

## 13. Текущая развилка проекта

Сейчас проект в точке выбора:

### Вариант A: продолжать латать текущую модель

- Плюс: быстрое краткосрочное облегчение по отдельным кейсам.
- Минус: высокая вероятность накопления ещё большей сложности.

### Вариант B: greenfield rewrite взаимодействия

- Плюс: чистая модель, предсказуемость, масштабируемость решений.
- Минус: требует дисциплины в проектировании и чёткой фазы обсуждения.

Ты уже выбрал Вариант B.

## 14. Картина зрелости на сегодня

### 14.1 Что уже зрелое

1. Продуктовая идея и режим понятны.
2. Пользовательский цикл сформирован.
3. UI и UX-направление в целом есть.
4. Понимание проблем сформулировано честно и чётко.

### 14.2 Что ещё незрелое

1. Формально зафиксированная модель состояния (FSM) для сервера.
2. Единый современный протокол без исторического шума.
3. Чёткие правила reconnect/finish/cancel/results.
4. Критерии "готово к бою" именно для сетевой части.

## 15. Чего этот документ НЕ делает

1. Не предлагает финальную реализацию.
2. Не описывает детально классы и методы.
3. Не навязывает конкретный фреймворк-стек как единственно правильный.
4. Не закрывает архитектурные решения автоматически.

Он фиксирует стартовую реальность и точки принятия решений.

## 16. Практическое определение успеха rewrite (на языке продукта)

Переписывание можно считать успешным, если:

1. Игрок без объяснений проходит цикл "вошёл -> сыграл -> рематч" много раз подряд.
2. Нет ложных состояний в UI относительно серверной реальности.
3. Reconnect и временные сетевые сбои не ломают сессию комнаты.
4. Роль лидера и права действий однозначны.
5. Серия матчей проходит стабильно без ручного "оживления" комнаты.

## 17. Что уже можно считать правильной рабочей стратегией

1. Сначала выравнивание продуктовых правил.
2. Потом выравнивание протокольных контрактов.
3. Потом реализация сервера как state machine, а не набора обработчиков "по месту".
4. Потом адаптация клиентского interaction-слоя под новый протокол без изменений UI.
5. Потом целевой прогон сценариев длинной сессии и edge-cases.

## 18. Текущий уровень определённости (честный)

### Уже определено

1. Нужен полный rewrite взаимодействия.
2. UI не трогаем.
3. Legacy-кашу разгребать точечно невыгодно.
4. Нужна дискуссия и формирование целостной картины перед кодом.

### Ещё не определено (и это нормально)

1. Финальная модель фаз матча.
2. Политики отмены/остановки.
3. Политика reconnection и сроков grace.
4. Политика завершения раунда и публикации результатов.
5. Границы серверной авторитетности.

## 19. Ключевая мысль текущего момента

Сейчас ты не "тормозишь разработку".  
Сейчас ты делаешь необходимую инженерную паузу, чтобы:

- не утонуть в локальных костылях;
- не повторить ту же ошибку на новом стеке;
- перевести режим из состояния "работает, но ненадёжно" в состояние "стабильный продуктовый цикл".

## 20. Рекомендованное использование этого слепка

Использовать этот документ как baseline в каждом обсуждении, пока не будет:

1. утверждённой продуктовой модели матча;
2. утверждённой модели состояний;
3. утверждённого протокола;
4. поэтапного плана реализации rewrite.

---

## Приложение A: Короткая формулировка твоего текущего запроса

> "Нужно полностью переписать клиент-серверное взаимодействие, не трогая UI клиента.  
> Legacy-логика слишком запутана и её точечная стабилизация, скорее всего, дороже и медленнее.  
> Перед реализацией нужно выстроить целостную картину и понять систему на уровне продукта и архитектурных принципов."

## Приложение B: Что важно не потерять в коммуникации команды

1. Отделять продуктовые правила от технических деталей.
2. Фиксировать решения письменно, а не "держать в голове".
3. Не смешивать фазу обсуждения и фазу кодинга.
4. Проверять каждое техническое решение на соответствие продуктовой цели: быстрый, честный, предсказуемый матчевый цикл.
